# -*- coding: utf-8 -*-
"""
* 부분 집합의 합 문제
유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서
그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
ex)
{-7, -3, -2, 5, 8}의 부분집합 {-3, -2, 5}는 원소의 합이 0이므로 참

부분 집합의 수
1. 집합의 원소가 n개일 때, 공집합을 포함한 부분 집합의 수는 2^n개
2. 각 원소를 부분 집합에 포함시키거나 포함하지 않는 2가지 경우를
   모든 원소에 적용한 경우의 수와 같음
   
Loop를 이용하여 확인하고, 부분 집합을 생성하는 방법
bit = [0, 0, 0, 0]
# 비트 list는 각 대상의 원소를 포함할지 말지를 정하는 List
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            for l in range(2):
                bit[3] = l
                print(bit)


비트 연산자 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자
&  : 비트 단위로 AND 연산을 함
|  : 비트 단위로 OR 연산을 함
<< : 피연산자의 비트 열을 왼쪽으로 이동 시킴(x2)
>> : 피연산자의 비트 열을 오른쪽으로 이동 시킴(//2)


* 보다 간결하게 부분 집합을 생성하는 방법
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)  # n: 원소의 개수

for i in range(1<<n):  # 1<<n: 부분 집합의 개수
    for j in range(n):  # 원소의 수65만큼 비트를 비교함
        if i&(1<<j):  # i의 j번째 비트가 1이면 j번째 원소 출력
            print(arr[j], end=",")


# 보다 간결하게 부분 집합을 생성하는 방법
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)  # n: 원소의 개수

for i in range(1<<n):  # 1<<n: 부분 집합의 개수
    for j in range(n):  # 원소의 수만큼 비트를 비교함
        if i&(1<<j):  # i의 j번째 비트가 1이면 j번째 원소 출력
            print(arr[j], end=",")
    print()
















"""


            
            
            
            
            
            
            
            
            
            